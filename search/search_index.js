const local_index = {"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Lighthouse Scalars This package provides a set of custom scalars for the webonyx/graphql-php library, which is used under the hood by Lighthouse , a PHP port of the popular GraphQL server. Supported Scalars The following scalars are supported: \ud83d\ude0d\ud83d\ude0d\ud83d\ude0d: Emoji - see Emoji Numbers: PositiveFloat - see Positive number NegativeFloat - see Negative number PositiveInt - see Positive integer NegativeInt Localization: CurrencyCode - see ISO 4217 alpha-3 CountryCode - see ISO 3166-1 alpha-2 Email - see RFC 5322 LanguageCode - see ISO 639-1 Locale - Simple locale string. see Locale ( en , en-US , en-GB , fr , fr-FR , fr-CA , etc.) Geography: Latitude - Extends GeoCoordinate. see Latitude Longitude - Extends GeoCoordinate. see Longitude GeoCoordinate - see Geographic coordinate system CountryCode - see ISO 3166-1 alpha-2 Internet: URL - see URL URI - see URI IPv4 - see IPv4 IPv6 - see IPv6 SemVer - see Semantic Versioning UUID - Using UUID4. see UUID Markup: JSON - see JSON HTML - Sanitised using HTML Purifier to prevent XSS attacks. see HTML Markdown - see Markdown Installation You can install the package via composer: composer require odder/lighthouse-scalars Usage Using Lighthouse You can opt-in to the scalars you want by registering them in the TypeRegistry in a service provider. For example, you can register the PositiveFloat and Emoji scalars in the AppServiceProvider : use Odder\\LighthouseScalars\\Scalars; use Nuwave\\Lighthouse\\Schema\\TypeRegistry; class AppServiceProvider extends ServiceProvider { public function boot() { ... } public function register(TypeRegistry $typeRegistry) { $typeRegistry->register(Scalars::PositiveFloat); $typeRegistry->register(Scalars::Emoji); } } After you have registered the Scalars you need in the TypeRegistry , you can use them in your schema: type Query { mood: Emoji! naturalNumber: PositiveFloat! } Testing This package includes a set of tests for each scalar. To run the tests, use the following command: composer test Documentation For more information on how to use each scalar, please refer to the documentation . Contributing Contributions are welcome! Please read CONTRIBUTING.md for details on how to contribute to this project. License The MIT License (MIT). Please see License File for more information. Credits Odder All Contributors webonyx/graphql-php Lighthouse Laravel GraphQL Security If you discover any security-related issues, please email hi@odder.dev instead of using the issue tracker. Roadmap For v1.0.0: Clean up scalar classes Clean up Tests Clean up Docs Add support for Time/Date scalars Add support for BigInt Scalars Get feedback from community Add implementation guides in the documentation Add Logo Add more emojis. \ud83d\ude0d\ud83d\ude0d\ud83d\ude0d Bake Cake \ud83c\udf70","title":"Lighthouse Scalars"},{"location":"index.html#lighthouse-scalars","text":"This package provides a set of custom scalars for the webonyx/graphql-php library, which is used under the hood by Lighthouse , a PHP port of the popular GraphQL server.","title":"Lighthouse Scalars"},{"location":"index.html#supported-scalars","text":"The following scalars are supported: \ud83d\ude0d\ud83d\ude0d\ud83d\ude0d: Emoji - see Emoji Numbers: PositiveFloat - see Positive number NegativeFloat - see Negative number PositiveInt - see Positive integer NegativeInt Localization: CurrencyCode - see ISO 4217 alpha-3 CountryCode - see ISO 3166-1 alpha-2 Email - see RFC 5322 LanguageCode - see ISO 639-1 Locale - Simple locale string. see Locale ( en , en-US , en-GB , fr , fr-FR , fr-CA , etc.) Geography: Latitude - Extends GeoCoordinate. see Latitude Longitude - Extends GeoCoordinate. see Longitude GeoCoordinate - see Geographic coordinate system CountryCode - see ISO 3166-1 alpha-2 Internet: URL - see URL URI - see URI IPv4 - see IPv4 IPv6 - see IPv6 SemVer - see Semantic Versioning UUID - Using UUID4. see UUID Markup: JSON - see JSON HTML - Sanitised using HTML Purifier to prevent XSS attacks. see HTML Markdown - see Markdown","title":"Supported Scalars"},{"location":"index.html#installation","text":"You can install the package via composer: composer require odder/lighthouse-scalars","title":"Installation"},{"location":"index.html#usage","text":"","title":"Usage"},{"location":"index.html#using-lighthouse","text":"You can opt-in to the scalars you want by registering them in the TypeRegistry in a service provider. For example, you can register the PositiveFloat and Emoji scalars in the AppServiceProvider : use Odder\\LighthouseScalars\\Scalars; use Nuwave\\Lighthouse\\Schema\\TypeRegistry; class AppServiceProvider extends ServiceProvider { public function boot() { ... } public function register(TypeRegistry $typeRegistry) { $typeRegistry->register(Scalars::PositiveFloat); $typeRegistry->register(Scalars::Emoji); } } After you have registered the Scalars you need in the TypeRegistry , you can use them in your schema: type Query { mood: Emoji! naturalNumber: PositiveFloat! }","title":"Using Lighthouse"},{"location":"index.html#testing","text":"This package includes a set of tests for each scalar. To run the tests, use the following command: composer test","title":"Testing"},{"location":"index.html#documentation","text":"For more information on how to use each scalar, please refer to the documentation .","title":"Documentation"},{"location":"index.html#contributing","text":"Contributions are welcome! Please read CONTRIBUTING.md for details on how to contribute to this project.","title":"Contributing"},{"location":"index.html#license","text":"The MIT License (MIT). Please see License File for more information.","title":"License"},{"location":"index.html#credits","text":"Odder All Contributors webonyx/graphql-php Lighthouse Laravel GraphQL","title":"Credits"},{"location":"index.html#security","text":"If you discover any security-related issues, please email hi@odder.dev instead of using the issue tracker.","title":"Security"},{"location":"index.html#roadmap","text":"For v1.0.0: Clean up scalar classes Clean up Tests Clean up Docs Add support for Time/Date scalars Add support for BigInt Scalars Get feedback from community Add implementation guides in the documentation Add Logo Add more emojis. \ud83d\ude0d\ud83d\ude0d\ud83d\ude0d Bake Cake \ud83c\udf70","title":"Roadmap"},{"location":"Custom%20Scalars/GenericScalarType.html","text":"GenericScalarType Description A generic scalar type which support out of box coercing and validation. This scalar should support most basic Scalar types. Usage Simple example use Odder\\LighthouseScalars\\Core\\GenericScalarType; class Email extends GenericScalarType { public ?string $description = \"The `Email` scalar type represents textual data, specifically an email address.\"; protected function isValid($value): bool { return filter_var($value, FILTER_VALIDATE_EMAIL) !== false; } } Full example use Odder\\LighthouseScalars\\Core\\GenericScalarType; class RomanNumeral extends GenericScalarType { protected string $supportedNodeType = \\GraphQL\\Language\\AST\\StringValueNode::class public ?string $description = \"The `RomanNumeral` scalar type a Roman numeral. Data is stored as integers, but displayed as Roman numerals.\"; public function coerce($value): int { // Convert the Roman numeral to an integer } public function coerceOut($value): string { // Convert the integer to a Roman numeral } protected function isValid($value): bool { // Validate the integer can be represented as a Roman Numeral (e.g. 1-3999) } protected function isValidOut($value): bool { // Validate the Roman numeral is valid } } Reference supportedNodeType protected string $supportedNodeType = ValueNode::class The AST node type that this scalar supports. This is used to validate the input type for literals. By default, this is set to ValueNode::class . description public ?string $description = null The description of the scalar type. This is used to generate documentation. coerce($value) public function coerce($value): mixed Coerce the input value to the expected type. This is used to convert the input value to the expected type. Exceptions should be thrown if the value cannot be coerced. This will be caught and handled by the GraphQL engine. coerceOut($value) public function coerceOut($value): mixed Coerce the output value to the expected type. This is used to convert the output value to the expected type. Exceptions should be thrown if the value cannot be coerced. This will be caught and handled by the GraphQL engine. Default implementation: public function coerceOut($value): mixed { return $this->coerce($value); } isValid($value) protected function isValid($value): bool Validate the input value. This is used to validate the input value. Return true if the value is valid, false otherwise. isValidOut($value) protected function isValidOut($value): bool Validate the output value. This is used to validate the output value. Return true if the value is valid, false otherwise. Default implementation: protected function isValidOut($value): bool { return $this->isValid($value); }","title":"GenericScalarType"},{"location":"Custom%20Scalars/GenericScalarType.html#genericscalartype","text":"","title":"GenericScalarType"},{"location":"Custom%20Scalars/GenericScalarType.html#description","text":"A generic scalar type which support out of box coercing and validation. This scalar should support most basic Scalar types.","title":"Description"},{"location":"Custom%20Scalars/GenericScalarType.html#usage","text":"","title":"Usage"},{"location":"Custom%20Scalars/GenericScalarType.html#simple-example","text":"use Odder\\LighthouseScalars\\Core\\GenericScalarType; class Email extends GenericScalarType { public ?string $description = \"The `Email` scalar type represents textual data, specifically an email address.\"; protected function isValid($value): bool { return filter_var($value, FILTER_VALIDATE_EMAIL) !== false; } }","title":"Simple example"},{"location":"Custom%20Scalars/GenericScalarType.html#full-example","text":"use Odder\\LighthouseScalars\\Core\\GenericScalarType; class RomanNumeral extends GenericScalarType { protected string $supportedNodeType = \\GraphQL\\Language\\AST\\StringValueNode::class public ?string $description = \"The `RomanNumeral` scalar type a Roman numeral. Data is stored as integers, but displayed as Roman numerals.\"; public function coerce($value): int { // Convert the Roman numeral to an integer } public function coerceOut($value): string { // Convert the integer to a Roman numeral } protected function isValid($value): bool { // Validate the integer can be represented as a Roman Numeral (e.g. 1-3999) } protected function isValidOut($value): bool { // Validate the Roman numeral is valid } }","title":"Full example"},{"location":"Custom%20Scalars/GenericScalarType.html#reference","text":"","title":"Reference"},{"location":"Custom%20Scalars/GenericScalarType.html#supportednodetype","text":"protected string $supportedNodeType = ValueNode::class The AST node type that this scalar supports. This is used to validate the input type for literals. By default, this is set to ValueNode::class .","title":"supportedNodeType"},{"location":"Custom%20Scalars/GenericScalarType.html#description_1","text":"public ?string $description = null The description of the scalar type. This is used to generate documentation.","title":"description"},{"location":"Custom%20Scalars/GenericScalarType.html#coercevalue","text":"public function coerce($value): mixed Coerce the input value to the expected type. This is used to convert the input value to the expected type. Exceptions should be thrown if the value cannot be coerced. This will be caught and handled by the GraphQL engine.","title":"coerce($value)"},{"location":"Custom%20Scalars/GenericScalarType.html#coerceoutvalue","text":"public function coerceOut($value): mixed Coerce the output value to the expected type. This is used to convert the output value to the expected type. Exceptions should be thrown if the value cannot be coerced. This will be caught and handled by the GraphQL engine. Default implementation: public function coerceOut($value): mixed { return $this->coerce($value); }","title":"coerceOut($value)"},{"location":"Custom%20Scalars/GenericScalarType.html#isvalidvalue","text":"protected function isValid($value): bool Validate the input value. This is used to validate the input value. Return true if the value is valid, false otherwise.","title":"isValid($value)"},{"location":"Custom%20Scalars/GenericScalarType.html#isvalidoutvalue","text":"protected function isValidOut($value): bool Validate the output value. This is used to validate the output value. Return true if the value is valid, false otherwise. Default implementation: protected function isValidOut($value): bool { return $this->isValid($value); }","title":"isValidOut($value)"},{"location":"Scalars/CountryCode.html","text":"Country Code Description Following the ISO 3166-1 alpha-2 standard, the country code is a two-letter code that represents a country. Examples: US - United States CA - Canada GB - United Kingdom FR - France Coercions The country code is coerced to uppercase. Validations The country code is validated using the ISO 3166-1 alpha-2 standard. Usage # schema.graphql type Query { country(code: CountryCode!): Country! } type Country { name: String! code: CountryCode! } # request query { country(code: \"US\") { name code } } # { # \"data\": { # \"country\": { # \"name\": \"United States\", # \"code\": \"US\" # } # } # }","title":"Country Code"},{"location":"Scalars/CountryCode.html#country-code","text":"","title":"Country Code"},{"location":"Scalars/CountryCode.html#description","text":"Following the ISO 3166-1 alpha-2 standard, the country code is a two-letter code that represents a country. Examples: US - United States CA - Canada GB - United Kingdom FR - France","title":"Description"},{"location":"Scalars/CountryCode.html#coercions","text":"The country code is coerced to uppercase.","title":"Coercions"},{"location":"Scalars/CountryCode.html#validations","text":"The country code is validated using the ISO 3166-1 alpha-2 standard.","title":"Validations"},{"location":"Scalars/CountryCode.html#usage","text":"# schema.graphql type Query { country(code: CountryCode!): Country! } type Country { name: String! code: CountryCode! } # request query { country(code: \"US\") { name code } } # { # \"data\": { # \"country\": { # \"name\": \"United States\", # \"code\": \"US\" # } # } # }","title":"Usage"},{"location":"Scalars/CurrencyCode.html","text":"Currency Code Description Following the ISO 4217 standard , the currency code is a three-letter code that represents a currency. Examples: USD - United States Dollar CAD - Canadian Dollar GBP - British Pound EUR - Euro JPY - Japanese Yen Please note: Cryptocurrencies are not included in this standard. Coercions The currency code is coerced to uppercase. Validations The currency code is validated using the ISO 4217 alpha-3 standard. Usage # schema.graphql type Query { currency(code: CurrencyCode!): Currency! } type Currency { name: String! code: CurrencyCode! } # request query { currency(code: \"USD\") { name code } } # { # \"data\": { # \"currency\": { # \"name\": \"United States Dollar\", # \"code\": \"USD\" # } # } # }","title":"Currency Code"},{"location":"Scalars/CurrencyCode.html#currency-code","text":"","title":"Currency Code"},{"location":"Scalars/CurrencyCode.html#description","text":"Following the ISO 4217 standard , the currency code is a three-letter code that represents a currency. Examples: USD - United States Dollar CAD - Canadian Dollar GBP - British Pound EUR - Euro JPY - Japanese Yen Please note: Cryptocurrencies are not included in this standard.","title":"Description"},{"location":"Scalars/CurrencyCode.html#coercions","text":"The currency code is coerced to uppercase.","title":"Coercions"},{"location":"Scalars/CurrencyCode.html#validations","text":"The currency code is validated using the ISO 4217 alpha-3 standard.","title":"Validations"},{"location":"Scalars/CurrencyCode.html#usage","text":"# schema.graphql type Query { currency(code: CurrencyCode!): Currency! } type Currency { name: String! code: CurrencyCode! } # request query { currency(code: \"USD\") { name code } } # { # \"data\": { # \"currency\": { # \"name\": \"United States Dollar\", # \"code\": \"USD\" # } # } # }","title":"Usage"},{"location":"Scalars/Email.html","text":"Email Description Following the RFC 5322 standard, the Email scalar type represents textual data, specifically an email address. Coercions No coercions are applied to the email address. Validations The email address is validated using the RFC 5322 standard. Using the filter_var function with the FILTER_VALIDATE_EMAIL filter. Usage # schema.graphql type Query { user(email: Email!): User! } type User { name: String! email: Email! } # request query { user(email: \"example@example.org\") { name email } } # { # \"data\": { # \"user\": { # \"name\": \"Example\", # \"email\": \"example@example.org\" # } # } # }","title":"Email"},{"location":"Scalars/Email.html#email","text":"","title":"Email"},{"location":"Scalars/Email.html#description","text":"Following the RFC 5322 standard, the Email scalar type represents textual data, specifically an email address.","title":"Description"},{"location":"Scalars/Email.html#coercions","text":"No coercions are applied to the email address.","title":"Coercions"},{"location":"Scalars/Email.html#validations","text":"The email address is validated using the RFC 5322 standard. Using the filter_var function with the FILTER_VALIDATE_EMAIL filter.","title":"Validations"},{"location":"Scalars/Email.html#usage","text":"# schema.graphql type Query { user(email: Email!): User! } type User { name: String! email: Email! } # request query { user(email: \"example@example.org\") { name email } } # { # \"data\": { # \"user\": { # \"name\": \"Example\", # \"email\": \"example@example.org\" # } # } # }","title":"Usage"},{"location":"Scalars/Emoji.html","text":"Emoji Description String expecting exactly one unicode emoji. Examples: \ud83d\ude42 \ud83d\udc4d \ud83c\udf55 \ud83d\ude80 \ud83c\udf89 \ud83d\udd25 Coercions No coercions are applied to the emoji. Validations The emoji is validated using the emoji-detector-php library. Usage # schema.graphql type Query { mood: Emoji! } # request query { mood } { \"data\" : { \"mood\" : \"\ud83d\ude42\" } }","title":"Emoji"},{"location":"Scalars/Emoji.html#emoji","text":"","title":"Emoji"},{"location":"Scalars/Emoji.html#description","text":"String expecting exactly one unicode emoji. Examples: \ud83d\ude42 \ud83d\udc4d \ud83c\udf55 \ud83d\ude80 \ud83c\udf89 \ud83d\udd25","title":"Description"},{"location":"Scalars/Emoji.html#coercions","text":"No coercions are applied to the emoji.","title":"Coercions"},{"location":"Scalars/Emoji.html#validations","text":"The emoji is validated using the emoji-detector-php library.","title":"Validations"},{"location":"Scalars/Emoji.html#usage","text":"# schema.graphql type Query { mood: Emoji! } # request query { mood } { \"data\" : { \"mood\" : \"\ud83d\ude42\" } }","title":"Usage"},{"location":"Scalars/GeoCoordinate.html","text":"GeoCoordinate Description SHOULD NOT BE USED DIRECTLY A float value representing a geographic coordinate. The value must be within the range of -90 to 90 for latitude and -180 to 180 for longitude. Examples: 40.7128 - New York City Latitude -74.0060 - New York City Longitude 51.5074 - London Latitude -0.1278 - London Longitude 48.8566 - Paris Latitude 2.3522 - Paris Longitude 34.0522 - Los Angeles Latitude -118.2437 - Los Angeles Longitude Coercions The value is coerced to a float. Supports input as sexagesimal degrees (DMS) in the format 40\u00b0 26' 46\" N or 40\u00b0 26' 46\" W . Validations The value is validated to be within the range of -180 to 180. Usage # schema.graphql type Query { location: Location! } type Location { name: String! coordinate: [GeoCoordinate!]! } # request query { location { name coordinate } } # { # \"data\": { # \"location\": { # \"name\": \"New York City\", # \"coordinate\": [40.7128, -74.0060] # } # } # }","title":"GeoCoordinate"},{"location":"Scalars/GeoCoordinate.html#geocoordinate","text":"","title":"GeoCoordinate"},{"location":"Scalars/GeoCoordinate.html#description","text":"SHOULD NOT BE USED DIRECTLY A float value representing a geographic coordinate. The value must be within the range of -90 to 90 for latitude and -180 to 180 for longitude. Examples: 40.7128 - New York City Latitude -74.0060 - New York City Longitude 51.5074 - London Latitude -0.1278 - London Longitude 48.8566 - Paris Latitude 2.3522 - Paris Longitude 34.0522 - Los Angeles Latitude -118.2437 - Los Angeles Longitude","title":"Description"},{"location":"Scalars/GeoCoordinate.html#coercions","text":"The value is coerced to a float. Supports input as sexagesimal degrees (DMS) in the format 40\u00b0 26' 46\" N or 40\u00b0 26' 46\" W .","title":"Coercions"},{"location":"Scalars/GeoCoordinate.html#validations","text":"The value is validated to be within the range of -180 to 180.","title":"Validations"},{"location":"Scalars/GeoCoordinate.html#usage","text":"# schema.graphql type Query { location: Location! } type Location { name: String! coordinate: [GeoCoordinate!]! } # request query { location { name coordinate } } # { # \"data\": { # \"location\": { # \"name\": \"New York City\", # \"coordinate\": [40.7128, -74.0060] # } # } # }","title":"Usage"},{"location":"Scalars/HTML.html","text":"HTML Description String representing HTML content. Coercions No coercions are applied to the HTML content. Validations The HTML content is validated using the HTML Purifier library. Usage # schema.graphql type Query { post(id: ID!): Post! } type Post { title: String! content: HTML! } # request query { post(id: \"1\") { title content } } # { # \"data\": { # \"post\": { # \"title\": \"Hello, World!\", # \"content\": \"<p>Hello, World!</p>\" # } # } # }","title":"HTML"},{"location":"Scalars/HTML.html#html","text":"","title":"HTML"},{"location":"Scalars/HTML.html#description","text":"String representing HTML content.","title":"Description"},{"location":"Scalars/HTML.html#coercions","text":"No coercions are applied to the HTML content.","title":"Coercions"},{"location":"Scalars/HTML.html#validations","text":"The HTML content is validated using the HTML Purifier library.","title":"Validations"},{"location":"Scalars/HTML.html#usage","text":"# schema.graphql type Query { post(id: ID!): Post! } type Post { title: String! content: HTML! } # request query { post(id: \"1\") { title content } } # { # \"data\": { # \"post\": { # \"title\": \"Hello, World!\", # \"content\": \"<p>Hello, World!</p>\" # } # } # }","title":"Usage"},{"location":"Scalars/IPv4.html","text":"IPv4 Description Following the IPv4 standard, the IPv4 scalar type represents textual data, specifically an IPv4 address. Examples: 123.23.12.143 93.23.0.1 128.0.0.1 Coercions The IPv4 address is coerced to a string. Validations The IPv4 address is validated using the IPv4 standard. Using the filter_var function with the FILTER_VALIDATE_IP filter. Usage # schema.graphql type Query { server(ip: IPv4!): Server! } type Server { name: String! ip: IPv4! } # request query { server (ip: \"128.0.0.1\") { name ip } } # { # \"data\": { # \"server\": { # \"name\": \"Server 1\", # \"ip\": \"128.0.0.1\" # } # } # }","title":"IPv4"},{"location":"Scalars/IPv4.html#ipv4","text":"","title":"IPv4"},{"location":"Scalars/IPv4.html#description","text":"Following the IPv4 standard, the IPv4 scalar type represents textual data, specifically an IPv4 address. Examples: 123.23.12.143 93.23.0.1 128.0.0.1","title":"Description"},{"location":"Scalars/IPv4.html#coercions","text":"The IPv4 address is coerced to a string.","title":"Coercions"},{"location":"Scalars/IPv4.html#validations","text":"The IPv4 address is validated using the IPv4 standard. Using the filter_var function with the FILTER_VALIDATE_IP filter.","title":"Validations"},{"location":"Scalars/IPv4.html#usage","text":"# schema.graphql type Query { server(ip: IPv4!): Server! } type Server { name: String! ip: IPv4! } # request query { server (ip: \"128.0.0.1\") { name ip } } # { # \"data\": { # \"server\": { # \"name\": \"Server 1\", # \"ip\": \"128.0.0.1\" # } # } # }","title":"Usage"},{"location":"Scalars/IPv6.html","text":"IPv6 Description Following the RFC 4291 standard, the IPv6 scalar type represents textual data, specifically an IPv6 address. Examples: 2001:0db8:85a3:0000:0000:8a2e:0370:7334 Coercions The IPv6 address is coerced to a string. Validations The IPv6 address is validated using the RFC 4291 standard. Using the filter_var function with the FILTER_VALIDATE_IP filter. Usage # schema.graphql type Query { server(ip: IPv6!): Server! } type Server { name: String! ip: IPv6! } # request query { server (ip: \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\") { name ip } } # { # \"data\": { # \"server\": { # \"name\": \"Server 1\", # \"ip\": \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\" # } # } # }","title":"IPv6"},{"location":"Scalars/IPv6.html#ipv6","text":"","title":"IPv6"},{"location":"Scalars/IPv6.html#description","text":"Following the RFC 4291 standard, the IPv6 scalar type represents textual data, specifically an IPv6 address. Examples: 2001:0db8:85a3:0000:0000:8a2e:0370:7334","title":"Description"},{"location":"Scalars/IPv6.html#coercions","text":"The IPv6 address is coerced to a string.","title":"Coercions"},{"location":"Scalars/IPv6.html#validations","text":"The IPv6 address is validated using the RFC 4291 standard. Using the filter_var function with the FILTER_VALIDATE_IP filter.","title":"Validations"},{"location":"Scalars/IPv6.html#usage","text":"# schema.graphql type Query { server(ip: IPv6!): Server! } type Server { name: String! ip: IPv6! } # request query { server (ip: \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\") { name ip } } # { # \"data\": { # \"server\": { # \"name\": \"Server 1\", # \"ip\": \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\" # } # } # }","title":"Usage"},{"location":"Scalars/JSON.html","text":"JSON Description Following the RFC 7159 standard, the JSON scalar type represents textual data, specifically a JSON string. Coercions The JSON string is coerced to a string. Validations The JSON string is validated using json_decode function. Usage # schema.graphql type Query { config: JSON! } # request query { config } # { # \"data\": { # \"config\": \"{\\\"key\\\": \\\"value\\\"}\" # } # }","title":"JSON"},{"location":"Scalars/JSON.html#json","text":"","title":"JSON"},{"location":"Scalars/JSON.html#description","text":"Following the RFC 7159 standard, the JSON scalar type represents textual data, specifically a JSON string.","title":"Description"},{"location":"Scalars/JSON.html#coercions","text":"The JSON string is coerced to a string.","title":"Coercions"},{"location":"Scalars/JSON.html#validations","text":"The JSON string is validated using json_decode function.","title":"Validations"},{"location":"Scalars/JSON.html#usage","text":"# schema.graphql type Query { config: JSON! } # request query { config } # { # \"data\": { # \"config\": \"{\\\"key\\\": \\\"value\\\"}\" # } # }","title":"Usage"},{"location":"Scalars/LanguageCode.html","text":"LanguageCode Description Following the ISO 639-1 standard, the LanguageCode scalar type represents textual data, specifically a language code. The language code is a two-letter code that represents a language. Examples: en - English es - Spanish fr - French de - German it - Italian Coercions The language code is coerced to lowercase. Validations The language code is validated using the ISO 639-1 standard. Usage # schema.graphql type Query { translation(language: LanguageCode!): Translation! } type Translation { text: String! language: LanguageCode! } # request query { translation(language: \"en\") { text language } } # { # \"data\": { # \"translation\": { # \"text\": \"Hello World\", # \"language\": \"en\" # } # } # }","title":"LanguageCode"},{"location":"Scalars/LanguageCode.html#languagecode","text":"","title":"LanguageCode"},{"location":"Scalars/LanguageCode.html#description","text":"Following the ISO 639-1 standard, the LanguageCode scalar type represents textual data, specifically a language code. The language code is a two-letter code that represents a language. Examples: en - English es - Spanish fr - French de - German it - Italian","title":"Description"},{"location":"Scalars/LanguageCode.html#coercions","text":"The language code is coerced to lowercase.","title":"Coercions"},{"location":"Scalars/LanguageCode.html#validations","text":"The language code is validated using the ISO 639-1 standard.","title":"Validations"},{"location":"Scalars/LanguageCode.html#usage","text":"# schema.graphql type Query { translation(language: LanguageCode!): Translation! } type Translation { text: String! language: LanguageCode! } # request query { translation(language: \"en\") { text language } } # { # \"data\": { # \"translation\": { # \"text\": \"Hello World\", # \"language\": \"en\" # } # } # }","title":"Usage"},{"location":"Scalars/Latitude.html","text":"Latitude Description A float value representing a Longitude. The value must be within the range of -90 to 90. Examples: 40.7128 - New York City Latitude 51.5074 - London Latitude 48.8566 - Paris Latitude 34.0522 - Los Angeles Latitude -23.5505 - S\u00e3o Paulo Latitude Coercions The value is coerced to a float. Supports input as sexagesimal degrees (DMS) in the format 40\u00b0 26' 46\" N or 40\u00b0 26' 46\" W . Validations The value is validated to be within the range of -90 to 90. Usage # schema.graphql type Query { location: Coordinate! } type Coordinate { latitude: Latitude! longitude: Longitude! } # request query { location { latitude longitude } } # { # \"data\": { # \"location\": { # \"latitude\": 40.7128, # \"longitude\": -74.0060 # } # } # }","title":"Latitude"},{"location":"Scalars/Latitude.html#latitude","text":"","title":"Latitude"},{"location":"Scalars/Latitude.html#description","text":"A float value representing a Longitude. The value must be within the range of -90 to 90. Examples: 40.7128 - New York City Latitude 51.5074 - London Latitude 48.8566 - Paris Latitude 34.0522 - Los Angeles Latitude -23.5505 - S\u00e3o Paulo Latitude","title":"Description"},{"location":"Scalars/Latitude.html#coercions","text":"The value is coerced to a float. Supports input as sexagesimal degrees (DMS) in the format 40\u00b0 26' 46\" N or 40\u00b0 26' 46\" W .","title":"Coercions"},{"location":"Scalars/Latitude.html#validations","text":"The value is validated to be within the range of -90 to 90.","title":"Validations"},{"location":"Scalars/Latitude.html#usage","text":"# schema.graphql type Query { location: Coordinate! } type Coordinate { latitude: Latitude! longitude: Longitude! } # request query { location { latitude longitude } } # { # \"data\": { # \"location\": { # \"latitude\": 40.7128, # \"longitude\": -74.0060 # } # } # }","title":"Usage"},{"location":"Scalars/Locale.html","text":"Locale (simple format) Description Following the BCP 47 standard, the Locale scalar type represents textual data, specifically a locale code. The locale code is a string that represents a combination of a language and a region. This scalar only supports the language and language-region formats. Examples: en - English es-CO - Spanish (Colombia) fr-Be - French (Belgium) de-CH - German (Switzerland) it-IT - Italian (Italy) it - Italian Coercions The language code is coerced to lowercase. The region code is coerced to uppercase. The language and region codes are separated by a hyphen ( - ). Supports input with _ as well Examples: en -> en EN -> en en_US -> en-US en_us -> en-US EN_US -> en-US en-us -> en-US Validations The locale code is validated in two steps, first the language code is validated using the ISO 639-1 standard, and then the region code is validated using the ISO 3166-1 alpha-2 standard. Usage # schema.graphql type Query { translation(locale: Locale!): Translation! } type Translation { text: String! locale: Locale! } # request query { translation(locale: \"en-US\") { text locale } } # { # \"data\": { # \"translation\": { # \"text\": \"Hello World\", # \"locale\": \"en-US\" # } # } # }","title":"Locale (simple format)"},{"location":"Scalars/Locale.html#locale-simple-format","text":"","title":"Locale (simple format)"},{"location":"Scalars/Locale.html#description","text":"Following the BCP 47 standard, the Locale scalar type represents textual data, specifically a locale code. The locale code is a string that represents a combination of a language and a region. This scalar only supports the language and language-region formats. Examples: en - English es-CO - Spanish (Colombia) fr-Be - French (Belgium) de-CH - German (Switzerland) it-IT - Italian (Italy) it - Italian","title":"Description"},{"location":"Scalars/Locale.html#coercions","text":"The language code is coerced to lowercase. The region code is coerced to uppercase. The language and region codes are separated by a hyphen ( - ). Supports input with _ as well Examples: en -> en EN -> en en_US -> en-US en_us -> en-US EN_US -> en-US en-us -> en-US","title":"Coercions"},{"location":"Scalars/Locale.html#validations","text":"The locale code is validated in two steps, first the language code is validated using the ISO 639-1 standard, and then the region code is validated using the ISO 3166-1 alpha-2 standard.","title":"Validations"},{"location":"Scalars/Locale.html#usage","text":"# schema.graphql type Query { translation(locale: Locale!): Translation! } type Translation { text: String! locale: Locale! } # request query { translation(locale: \"en-US\") { text locale } } # { # \"data\": { # \"translation\": { # \"text\": \"Hello World\", # \"locale\": \"en-US\" # } # } # }","title":"Usage"},{"location":"Scalars/Longitude.html","text":"Longitude Description A float value representing a Longitude. The value must be within the range of -180 to 180. Examples: -74.0060 - New York City Longitude -0.1278 - London Longitude 2.3522 - Paris Longitude -118.2437 - Los Angeles Longitude Coercions The value is coerced to a float. Supports input as sexagesimal degrees (DMS) in the format 40\u00b0 26' 46\" N or 40\u00b0 26' 46\" W . Validations The value is validated to be within the range of -180 to 180. Usage # schema.graphql type Query { location: Coordinate! } type Coordinate { latitude: Latitude! longitude: Longitude! } # request query { location { latitude longitude } } # { # \"data\": { # \"location\": { # \"latitude\": 40.7128, # \"longitude\": -74.0060 # } # } # }","title":"Longitude"},{"location":"Scalars/Longitude.html#longitude","text":"","title":"Longitude"},{"location":"Scalars/Longitude.html#description","text":"A float value representing a Longitude. The value must be within the range of -180 to 180. Examples: -74.0060 - New York City Longitude -0.1278 - London Longitude 2.3522 - Paris Longitude -118.2437 - Los Angeles Longitude","title":"Description"},{"location":"Scalars/Longitude.html#coercions","text":"The value is coerced to a float. Supports input as sexagesimal degrees (DMS) in the format 40\u00b0 26' 46\" N or 40\u00b0 26' 46\" W .","title":"Coercions"},{"location":"Scalars/Longitude.html#validations","text":"The value is validated to be within the range of -180 to 180.","title":"Validations"},{"location":"Scalars/Longitude.html#usage","text":"# schema.graphql type Query { location: Coordinate! } type Coordinate { latitude: Latitude! longitude: Longitude! } # request query { location { latitude longitude } } # { # \"data\": { # \"location\": { # \"latitude\": 40.7128, # \"longitude\": -74.0060 # } # } # }","title":"Usage"},{"location":"Scalars/Markdown.html","text":"Markdown Description Following the Markdown standard, the Markdown scalar type represents textual data, specifically a Markdown string. Examples: # Title ## Subtitle ### Subsubtitle Hello **World** Coercions The Markdown string is coerced to a string. Validations The Markdown string is not currently validated. Usage # schema.graphql type Query { post(content: Markdown!): Post! } type Post { title: String! content: Markdown! } # request query { post(content: \"# Hello, World!\") { title content } } # { # \"data\": { # \"post\": { # \"title\": \"Hello, World!\", # \"content\": \"# Hello, World!\" # } # } # }","title":"Markdown"},{"location":"Scalars/Markdown.html#markdown","text":"","title":"Markdown"},{"location":"Scalars/Markdown.html#description","text":"Following the Markdown standard, the Markdown scalar type represents textual data, specifically a Markdown string. Examples: # Title ## Subtitle ### Subsubtitle Hello **World**","title":"Description"},{"location":"Scalars/Markdown.html#coercions","text":"The Markdown string is coerced to a string.","title":"Coercions"},{"location":"Scalars/Markdown.html#validations","text":"The Markdown string is not currently validated.","title":"Validations"},{"location":"Scalars/Markdown.html#usage","text":"# schema.graphql type Query { post(content: Markdown!): Post! } type Post { title: String! content: Markdown! } # request query { post(content: \"# Hello, World!\") { title content } } # { # \"data\": { # \"post\": { # \"title\": \"Hello, World!\", # \"content\": \"# Hello, World!\" # } # } # }","title":"Usage"},{"location":"Scalars/NegativeInteger.html","text":"Negative Integer Description The NegativeInteger scalar type represents a negative integer. 0 is considered a negative integer. The NegativeInteger is limited by the Int type of PHP and thus is limited to the range of -2,147,483,648 (-2^31) to 0. Examples: 0 -1 -2 Coercions The negative integer is coerced to an integer. Validations The negative integer is validated using the is_int function. The negative integer is also validated to be greater than or equal to 0. Usage # schema.graphql type Query { count: NegativeInteger! } # request query { count } # { # \"data\": { # \"count\": -30 # } # }","title":"Negative Integer"},{"location":"Scalars/NegativeInteger.html#negative-integer","text":"","title":"Negative Integer"},{"location":"Scalars/NegativeInteger.html#description","text":"The NegativeInteger scalar type represents a negative integer. 0 is considered a negative integer. The NegativeInteger is limited by the Int type of PHP and thus is limited to the range of -2,147,483,648 (-2^31) to 0. Examples: 0 -1 -2","title":"Description"},{"location":"Scalars/NegativeInteger.html#coercions","text":"The negative integer is coerced to an integer.","title":"Coercions"},{"location":"Scalars/NegativeInteger.html#validations","text":"The negative integer is validated using the is_int function. The negative integer is also validated to be greater than or equal to 0.","title":"Validations"},{"location":"Scalars/NegativeInteger.html#usage","text":"# schema.graphql type Query { count: NegativeInteger! } # request query { count } # { # \"data\": { # \"count\": -30 # } # }","title":"Usage"},{"location":"Scalars/PositiveInteger.html","text":"Positive Integer Description The PositiveInteger scalar type represents a positive integer. 0 is considered a positive integer. The PositiveInteger is limited by the Int type of PHP and thus is limited to the range of 0 to 2,147,483,647 (2^31 - 1). Examples: 0 1 2 Coercions The positive integer is coerced to an integer. Validations The positive integer is validated using the is_int function. The positive integer is also validated to be greater than or equal to 0. Usage # schema.graphql type Query { count: PositiveInteger! } # request query { count } # { # \"data\": { # \"count\": 30 # } # }","title":"Positive Integer"},{"location":"Scalars/PositiveInteger.html#positive-integer","text":"","title":"Positive Integer"},{"location":"Scalars/PositiveInteger.html#description","text":"The PositiveInteger scalar type represents a positive integer. 0 is considered a positive integer. The PositiveInteger is limited by the Int type of PHP and thus is limited to the range of 0 to 2,147,483,647 (2^31 - 1). Examples: 0 1 2","title":"Description"},{"location":"Scalars/PositiveInteger.html#coercions","text":"The positive integer is coerced to an integer.","title":"Coercions"},{"location":"Scalars/PositiveInteger.html#validations","text":"The positive integer is validated using the is_int function. The positive integer is also validated to be greater than or equal to 0.","title":"Validations"},{"location":"Scalars/PositiveInteger.html#usage","text":"# schema.graphql type Query { count: PositiveInteger! } # request query { count } # { # \"data\": { # \"count\": 30 # } # }","title":"Usage"},{"location":"Scalars/SemVer.html","text":"SemVer Description Following the Semantic Versioning standard, the SemVer scalar type represents textual data, specifically a semantic version. Examples: 1.0.0 2.3.4 3.0.0 3.0.1-alpha 3.0.1-alpha.1 Coercions The semantic version is coerced to a string. Validations The semantic version is validated using the Semantic Versioning standard. Usage # schema.graphql type Query { version: SemVer! } # request query { version } # { # \"data\": { # \"version\": \"1.0.0\" # } # }","title":"SemVer"},{"location":"Scalars/SemVer.html#semver","text":"","title":"SemVer"},{"location":"Scalars/SemVer.html#description","text":"Following the Semantic Versioning standard, the SemVer scalar type represents textual data, specifically a semantic version. Examples: 1.0.0 2.3.4 3.0.0 3.0.1-alpha 3.0.1-alpha.1","title":"Description"},{"location":"Scalars/SemVer.html#coercions","text":"The semantic version is coerced to a string.","title":"Coercions"},{"location":"Scalars/SemVer.html#validations","text":"The semantic version is validated using the Semantic Versioning standard.","title":"Validations"},{"location":"Scalars/SemVer.html#usage","text":"# schema.graphql type Query { version: SemVer! } # request query { version } # { # \"data\": { # \"version\": \"1.0.0\" # } # }","title":"Usage"},{"location":"Scalars/URI.html","text":"URI Description Following the RFC 3986 standard, the URI scalar type represents textual data, specifically a URI string. Examples: http://example.com ftp://example.com ssh://example.com Coercions The URI string is coerced to a string. Validations The URI string is validated using the parse_url function. Usage # schema.graphql type Query { resource(uri: URI!): Resource! } type Resource { title: String! uri: URI! } # request query { resource(uri: \"http://example.com\") { title uri } } # { # \"data\": { # \"resource\": { # \"title\": \"Example Domain\", # \"uri\": \"http://example.com\" # } # } # }","title":"URI"},{"location":"Scalars/URI.html#uri","text":"","title":"URI"},{"location":"Scalars/URI.html#description","text":"Following the RFC 3986 standard, the URI scalar type represents textual data, specifically a URI string. Examples: http://example.com ftp://example.com ssh://example.com","title":"Description"},{"location":"Scalars/URI.html#coercions","text":"The URI string is coerced to a string.","title":"Coercions"},{"location":"Scalars/URI.html#validations","text":"The URI string is validated using the parse_url function.","title":"Validations"},{"location":"Scalars/URI.html#usage","text":"# schema.graphql type Query { resource(uri: URI!): Resource! } type Resource { title: String! uri: URI! } # request query { resource(uri: \"http://example.com\") { title uri } } # { # \"data\": { # \"resource\": { # \"title\": \"Example Domain\", # \"uri\": \"http://example.com\" # } # } # }","title":"Usage"},{"location":"Scalars/URL.html","text":"URL Description Following the RFC 3986 standard, the URL scalar type represents textual data, specifically a URL string. Only URLs with the http and https schemes are supported. Examples: http://example.com https://example.com http://example.com/path https://example.com/path http://example.com/path?query=value http://example.com/path?query=value#fragment http://example.com:8080 Coercions The URL string is coerced to a string. Validations The URL string is validated using the parse_url function. Only URLs with the http and https schemes are supported. Usage # schema.graphql type Query { website(url: URL!): Website! } type Website { title: String! url: URL! } # request query { website(url: \"https://example.com\") { title url } } # { # \"data\": { # \"website\": { # \"title\": \"Example Domain\", # \"url\": \"https://example.com\" # } # } # }","title":"URL"},{"location":"Scalars/URL.html#url","text":"","title":"URL"},{"location":"Scalars/URL.html#description","text":"Following the RFC 3986 standard, the URL scalar type represents textual data, specifically a URL string. Only URLs with the http and https schemes are supported. Examples: http://example.com https://example.com http://example.com/path https://example.com/path http://example.com/path?query=value http://example.com/path?query=value#fragment http://example.com:8080","title":"Description"},{"location":"Scalars/URL.html#coercions","text":"The URL string is coerced to a string.","title":"Coercions"},{"location":"Scalars/URL.html#validations","text":"The URL string is validated using the parse_url function. Only URLs with the http and https schemes are supported.","title":"Validations"},{"location":"Scalars/URL.html#usage","text":"# schema.graphql type Query { website(url: URL!): Website! } type Website { title: String! url: URL! } # request query { website(url: \"https://example.com\") { title url } } # { # \"data\": { # \"website\": { # \"title\": \"Example Domain\", # \"url\": \"https://example.com\" # } # } # }","title":"Usage"},{"location":"Scalars/UUID.html","text":"UUID (UUID4) Description The UUID scalar type represents textual data, specifically a UUID string. The UUID is generated using the UUID version 4 standard. Examples: 550e8400-e29b-41d4-a716-446655440000 f47ac10b-58cc-4372-a567-0e02b2c3d479 d9e4b4e2-3e6f-4f3a-8a3f-3f6dd9d9d3d0 Coercions The UUID string is coerced to a string. Validations The UUID string is validated using a simple regular expression following the UUID version 4 standard. Usage # schema.graphql type Query { user(id: UUID!): User! } type User { id: UUID! name: String! } # request query { user(id: \"550e8400-e29b-41d4-a716-446655440000\") { id name } } # { # \"data\": { # \"user\": { # \"id\": \"550e8400-e29b-41d4-a716-446655440000\", # \"name\": \"John Doe\" # } # } # }","title":"UUID (UUID4)"},{"location":"Scalars/UUID.html#uuid-uuid4","text":"","title":"UUID (UUID4)"},{"location":"Scalars/UUID.html#description","text":"The UUID scalar type represents textual data, specifically a UUID string. The UUID is generated using the UUID version 4 standard. Examples: 550e8400-e29b-41d4-a716-446655440000 f47ac10b-58cc-4372-a567-0e02b2c3d479 d9e4b4e2-3e6f-4f3a-8a3f-3f6dd9d9d3d0","title":"Description"},{"location":"Scalars/UUID.html#coercions","text":"The UUID string is coerced to a string.","title":"Coercions"},{"location":"Scalars/UUID.html#validations","text":"The UUID string is validated using a simple regular expression following the UUID version 4 standard.","title":"Validations"},{"location":"Scalars/UUID.html#usage","text":"# schema.graphql type Query { user(id: UUID!): User! } type User { id: UUID! name: String! } # request query { user(id: \"550e8400-e29b-41d4-a716-446655440000\") { id name } } # { # \"data\": { # \"user\": { # \"id\": \"550e8400-e29b-41d4-a716-446655440000\", # \"name\": \"John Doe\" # } # } # }","title":"Usage"}]}; var __search = { index: Promise.resolve(local_index) }